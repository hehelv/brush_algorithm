### 数字三角形模型
```c++
/*
 * 数字三角形即形如f[i][j]<-(f[i-1][j],f[i][j-1])转移方程的模式
 * */
/*
    1.摘花生：给定一个二维矩阵，从左上角出发，每次只能向右或向下走，问从右下角出来时的经过点权值的最大值
        f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]
        cout<<f[n][m]
    2.最低同行费用：题目同上，但求的是最小值
        f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j]
        cout<<f[n][m];
    3.方格取数：从左上角到右下角按上述方式走两次，经过相同的点只会计算一次权值，求最大值
        定义状态f[k][i][j],表示走k步，A点横坐标为i，B点横坐标为j时的权值
        对于i==j特殊处理
        for(int k=2;k<=n+m;++k)
                for(int i1=1;i1<=n;++i1)
                    for(int i2=1;i2<=n;++i2){
                        int j1 = k-i1,j2=k-i2;
                        if(i1>=1&&i1<=n&&i2>=1&&i2<=n&&j1>=1&&j1<=m&&j2>=1&&j2<=m){
                            int t = a[i1][j1];
                            if(i1!=i2)t+=a[i2][j2];
                            //四个方向
                            int &cur = f[k][i1][i2];
                            cur = max(cur,f[k-1][i1][i2]+t);
                            cur = max(cur,f[k-1][i1-1][i2]+t);
                            cur = max(cur,f[k-1][i1][i2-1]+t);
                            cur = max(cur,f[k-1][i1-1][i2-1]+t);
                        }
                    }
            cout<<f[m+n][n][n];
    4.传纸条：题目约束不能经过相同的点，但是由于所有点都是正数，因此最优解会直接避免这种情况
*/
```

### 最长上升子序列模型
拦截导弹

拦截系统

最长**公共***上升*子序列
```c++
/*
    最长上升子序列模型
        1.f[i]=max(f[k])+1,a[k]<a[i]&&k<i
            初始化f[i]=1;
        2.使用二分查找优化：大则添加，小则替换（上升子序列小于等于替换，不下降子序列大于替换）
            b[1]=a[1];
            for(int i=2;i<=n;++i)
                if(a[i]>b[len])b[++len]=a[i];//大则添加
                else{//小于等于则替换->二分查找后替换
                    int l = 1,r=len;
                    while(l<r){//二分查找模板
                        int mid = (l+r)/2;//mid在左侧不添加
                        if(b[mid]>=a[i])r = mid;
                        else l = mid+1;
                    }
                    b[l]=a[i];
                }
    1.怪盗基德，求从左向右和从右向左的最长上升子序列的最大值，使用二分模板即可。
    2.登山，[1~i]的最长上升子序列长度与[i~n]的最长下降子序列（反向的最长上升子序列）的长度和减去1
        使用dp方法
    3.合唱队形，方法同登山
    4.友好城市，一条河两岸存在港口，一对对友好城市分布在两岸，互为友好城市的港口才能贸易，问在航线不相交的情况下至多有多少条航线。
        f[i]表示前i开通时，前i个港口的最大航线数 初始化f[i]=1
        f[i]=max(f[i],f[k]+1),k<i且k航线与i航线不相交
        max(f[i])为最终答案
    5.最大上升子序列的和：f[i]表示以i结尾的最大上升子和，初始化为a[i]
        f[i]=max(f[i],f[j]+a[i]),a[j]<a[i],j<i;
    6.拦截导弹：存在一个这样的系统，每次只能拦截不高于上一次的导弹，给定一群导弹的高度，问一次最多能拦截多少导弹，要全部拦截需要多少个这样的系统？
        问题一为最大不上升序列，使用模板即可。
        问题二考虑这样的一个贪心策略，对于每个导弹，都用能够拦截的高度最低的系统拦截，对于不能拦截的导弹，则增加一套系统。实际上这种方法就是最大上升子序列的二分查找优化：大则增加（所有系统都无法拦截了，只能增加一套系统拦截），小于等于（该导弹可以拦截）则替换（使用能够拦截的高度最低的系统进行拦截，拦截之后，其值就替换成了当前高度）
    7.拦截系统：该拦截系统只能单调向上或单调向下拦截，问最小需要多少套拦截系统？
        思路：对于每个导弹拥有两种情况，归入单调向下或者单调向上，通过深搜取所有答案的最小值
        爆搜剪枝：仅当当前拦截系统套数小于当前最优情况时，才进行搜索
        dfs通过定义全局变量求最小值，通过与当前最小值比较进行剪枝
        #include "iostream"
        using namespace std;
        int a[55],ans,up[55],down[55],n;
        void dfs(int pos,int len_up,int len_down){
            if(len_up+len_down>=ans)return;//剪枝
            if(pos==n+1){//到达搜索终点 更新最小值
                ans = min(ans,len_down+len_up);
                return;
            }
            //添加到上升子序列中
            int k = 1;
            while(k<=len_up&&a[pos]>up[k])k++;//找到第一个比它大的点 进行替换
            int t = up[k];//保存 用于深搜恢复
            up[k]=a[pos];
            dfs(pos+1,max(len_up,k),len_down);
            up[k]=t;//恢复状态
            //添加到下降子序列中
            k = 1;
            while(k<=len_down&&a[pos]<down[k])k++;
            t = down[k];
            down[k]=a[pos];
            dfs(pos+1,len_up,max(len_down,k));
            down[k]=t;
        }
        int main(){
            while(cin>>n,n){
                for(int i=1;i<=n;++i)cin>>a[i];
                ans = n;
                dfs(1,0,0);
                cout<<ans<<endl;
            }
        }
    8.最长公共上升子序列：最长公共上升子序列前置知识为最长上升子序列和最长公共子序列
        最长上升子序列:f[i]=max(f[j]+1),j<i&&a[j]<a[i]
        最长公共子序列:f[i][j]存储a[1~i],b[1~j]的最长公共子序列
            f[i][j]=f[i-1][j-1],a[i]==b[j]
            f[i][j]=max(f[i][j-1],f[i-1][j]),a[i]!=b[j],即a[i]不在和b[j]不在公共子序列中的最大值
        最长公共上升子序列：
            状态定义：f[i][j]表示a[1~i],b[1~j]中且以b[j]结尾的最长公共子序列的长度的最大值
            转移方程以a[i]是否在公共子序列中进行划分
                a[i]不在公共子序列中:此时a[i]的存在与否与f[i][j]没有影响，即
                    f[i][j]=f[i-1][j]
                a[i]在公共子序列中，此时要求a[i]=b[j]:此时仅考虑a[1~i-1]和b[1~j-1],此时枚举以b[k],1<=k<i的每种情况，即a[1~i-1]与b[1~k]的最长上升公共子序列的最大值+1（1为a[i]=b[j]）
                    f[i][j]=max(f[i-1][k]+1),b[k]<b[j]=a[i],k<j
            朴素方法:由状态转移方程得f[i][j]均由f[i-1][1~j]得到，则有
                for(int i=1;i<=n;++i)
                    for(int j=1;j<=m;++j){
                        f[i][j]=f[i-1][j];
                        if(a[i]==b[j]){
                            int maxv = 1;
                            for(int k=1;k<j;++k)//枚举a[1~i-1]和b[1~k]
                                maxv = max(maxv,f[i-1][k]+1);
                            f[i][j]=max(f[i][j],maxv);
                        }
                    }
                //由于状态表示以b[j]结尾的最大值，因此需要枚举f[n][j]
                int ans = 0;
                for(int i =1;i<=m;++i)ans = max(ans,f[n][i]);
                cout<<ans;
            对上述递推过程进行优化：maxv的含义为b[1~j-1]中小于a[i]的位置的最长公共子序列的最大值，对于每个b[j]=a[i],都会进行一次k循环，而k循环存在大量重复计算，可以在对j进行遍历时保存并更新maxv从而提高效率。
                for(int i=1;i<=n;++i){
                    int maxv = 1;
                    for(int j=1;j<=m;++j){
                        f[i][j]=f[i-1][j];
                        if(a[i]==b[j])f[i][j]=max(f[i][j],maxv);
                        if(b[j]<a[i])maxv=max(maxv,f[i-1][j]+1);//维护[1~j]中满足b[k]<a[i]的f[i-1][k]的最大值，用于j+1的更新
                    }
                }
 * */
```